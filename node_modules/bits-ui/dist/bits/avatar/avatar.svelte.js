import { untrack } from "svelte";
import { DOMContext, attachRef } from "svelte-toolbelt";
import { Context } from "runed";
import { createBitsAttrs } from "../../internal/attrs.js";
const avatarAttrs = createBitsAttrs({
    component: "avatar",
    parts: ["root", "image", "fallback"],
});
class AvatarRootState {
    opts;
    domContext;
    constructor(opts) {
        this.opts = opts;
        this.domContext = new DOMContext(this.opts.ref);
        this.loadImage = this.loadImage.bind(this);
    }
    loadImage(src, crossorigin, referrerPolicy) {
        if (this.opts.loadingStatus.current === "loaded")
            return;
        let imageTimerId;
        const image = new Image();
        image.src = src;
        if (crossorigin !== undefined)
            image.crossOrigin = crossorigin;
        if (referrerPolicy)
            image.referrerPolicy = referrerPolicy;
        this.opts.loadingStatus.current = "loading";
        image.onload = () => {
            imageTimerId = this.domContext.setTimeout(() => {
                this.opts.loadingStatus.current = "loaded";
            }, this.opts.delayMs.current);
        };
        image.onerror = () => {
            this.opts.loadingStatus.current = "error";
        };
        return () => {
            this.domContext.clearTimeout(imageTimerId);
        };
    }
    props = $derived.by(() => ({
        id: this.opts.id.current,
        [avatarAttrs.root]: "",
        "data-status": this.opts.loadingStatus.current,
        ...attachRef(this.opts.ref),
    }));
}
class AvatarImageState {
    opts;
    root;
    constructor(opts, root) {
        this.opts = opts;
        this.root = root;
        $effect.pre(() => {
            if (!this.opts.src.current) {
                this.root.opts.loadingStatus.current = "error";
                return;
            }
            // dependency on crossorigin
            this.opts.crossOrigin.current;
            untrack(() => this.root.loadImage(this.opts.src.current ?? "", this.opts.crossOrigin.current, this.opts.referrerPolicy.current));
        });
    }
    props = $derived.by(() => ({
        id: this.opts.id.current,
        style: {
            display: this.root.opts.loadingStatus.current === "loaded" ? "block" : "none",
        },
        "data-status": this.root.opts.loadingStatus.current,
        [avatarAttrs.image]: "",
        src: this.opts.src.current,
        crossorigin: this.opts.crossOrigin.current,
        referrerpolicy: this.opts.referrerPolicy.current,
        ...attachRef(this.opts.ref),
    }));
}
class AvatarFallbackState {
    opts;
    root;
    constructor(opts, root) {
        this.opts = opts;
        this.root = root;
    }
    style = $derived.by(() => this.root.opts.loadingStatus.current === "loaded" ? { display: "none" } : undefined);
    props = $derived.by(() => ({
        style: this.style,
        "data-status": this.root.opts.loadingStatus.current,
        [avatarAttrs.fallback]: "",
        ...attachRef(this.opts.ref),
    }));
}
const AvatarRootContext = new Context("Avatar.Root");
export function useAvatarRoot(props) {
    return AvatarRootContext.set(new AvatarRootState(props));
}
export function useAvatarImage(props) {
    return new AvatarImageState(props, AvatarRootContext.get());
}
export function useAvatarFallback(props) {
    return new AvatarFallbackState(props, AvatarRootContext.get());
}
